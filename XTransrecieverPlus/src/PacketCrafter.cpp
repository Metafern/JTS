#include "PacketCrafter.h"
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/hmac.h>

using namespace std;
using namespace pcpp;
using namespace util;
using namespace cfg;

uint64_t crft::PiaPacket::nonce = 0;

crft::PiaPacket::PiaPacket(Parser* parserIn) {
	parser = parserIn;
	header.nonce = &nonce;
	header.version = 0x84;

	message.field_flags = 0x7f;
	message.msg_flag = 0x09;
}
crft::PiaPacket::PiaPacket() {
	header.nonce = &nonce;
	header.version = 0x84;
}

Packet crft::PiaPacket::craftPacket(vector<uint8_t> data, int srcPort, int dstPort, int dstIP) {
	
	Packet out;
	MacAddress dstMac;
	if (dstIP == 0x0a0000ff)
		dstMac = MacAddress("ff:ff:ff:ff:ff:ff");
	else
		dstMac = MacAddress("7c:bb:8a:d5:52:bb");

	EthLayer eth(MacAddress("7c:bb:8a:dd:55:bb"), dstMac);
	out.addLayer(&eth);
	IPv4Layer ip;
	ip.getIPv4Header()->ipSrc = IPv4Address(string(interfaceIPAddr)).toInt();
	ip.getIPv4Header()->ipDst = htonl(dstIP);
	ip.getIPv4Header()->ipId = htons(2000);
	ip.getIPv4Header()->timeToLive = 64;
	out.addLayer(&ip);

	UdpLayer udp(srcPort, dstPort);
	out.addLayer(&udp);

	PayloadLayer payload(data.data(), data.size(), true);
	out.addLayer(&payload);
	out.computeCalculateFields();
	return out;
}

void crft::Lan::craftBrowseReq(Packet& in) {

	//lazy approach
	vector<uint8_t> data;
	HexToVector("000000023affffffff000400040101ffffffff000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020201000000000000000488c6f41cf3382b4157089e1c623487b5a031d818765bedd597ca0ce3a3c8ec6fedac053da5f495f0d8002f1cb241513a1d1c194fec6bba421d0c00a09577c90c0b54416ea6e75d62a636459abdcd5f1707dc71e6ea2cfe9a3fe83eb449b74d743b9e6ef38fdb9605004e08716e7c952796f684763a6a49ae13e5bd117261904a3ca85e5f7b1fca70c4df19093806cd2c9edbbb16fa5b902a4bceffdef848594abac7bda09009db083bec22617d7ccf671656fcbc7db01ef34172bcd2c024b19d838db0ae1cf25cd126fe576345860416c716ebf4c53cda1d2875f2ff68310ce25394eb7c60a9077e6a86824ddb594d11c87ec47f509638874827eb77b4cce2fb687c0474cddedac3380b2117255ddb3c32e614c6653b2199b577a400a80e36f2", &data);
	in = craftPacket(data, 30000, 30000);
}

void crft::Lan::craftHostReq(Packet& in) {

	vector<uint8_t> data;
	data.push_back(Lan::GET_HOST_REQ); //Packet ID
	for (int i = 0; i < 11; i++)
		data.push_back(0); //padding
	data.insert(data.end(), parser->sessionID.begin(), parser->sessionID.end());
	
	message.appendHeader(&data);

	vector<uint8_t> out;

	if (parser->EncryptPia(data, &out, header)) {
		in = craftPacket(out, 49155, 49152);
	}
}

void crft::Lan::craftBrowseRep(Packet& in) {
	/*
	//raw response
	uint8_t resp[32];
	HMAC(EVP_sha256(), GAME_KEY, 16, parser->message.payload.data(), parser->message.payload.size(), resp, nullptr);


	vector<uint8_t> selfKey;
	HexToVector("98408530300f066d20cf8fafa062cd87", &selfKey);

	vector<uint8_t> respKey;
	respKey.insert(respKey.end(), selfKey.begin(), selfKey.end());
	respKey.insert(respKey.end(), challengeKey.begin(), challengeKey.end());
	uint8_t encKey[32];
	HMAC(EVP_sha256(), GAME_KEY, 16, respKey.data(), respKey.size(), encKey, nullptr);


	//encrypt response
	array<uint8_t, 16> out;

	ctx = EVP_CIPHER_CTX_new();
	EVP_EncryptInit_ex(ctx, EVP_aes_128_gcm(), nullptr, encKey, challengeNonce.data());
	EVP_EncryptUpdate(ctx, out.data(), &len, resp, 16);
	EVP_EncryptFinal_ex(ctx, out.data() + out.size(), &len);
	EVP_CIPHER_CTX_free(ctx);
	
	
	vector<uint8_t> out;
	HexToVector("010000051100000000003dc003000000000000000000000000000000000000000000000000000100000004070500003205500d000002d46119ec17c85000a570046a39a699bc2442a92fe73400108babd9278ec8bbced3ef99039c01306e43006f006f006c000000046a39a699bc2442a92fe7340010081102ac310000090400000042ac11030e4c64b183014d3900024f0a4047b789470b292b44623b8347eaab2d3e5f47b789470b292b44623b8347eaab2d3e5e47b789470b292b44623b8347eaab2d3e02ff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db0038000801000032000000000000000e0025000200000039040200580012000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000168010a00003d000000000000000000000000c0030a00003d0000c00398e93f88003dc0030101536f6d656f6e650000000000000000000000000000000000000000000000000000000000000000000a00003d0000c003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cfe0ec237fb19af6aec596784129bb50e0997216b848f1fb8e6a0e332dd594440201", &out);
	out.insert(out.end(), challengeNonce.begin() + 4, challengeNonce.end());
	out.insert(out.end(), selfKey.begin(), selfKey.end());
	out.insert(out.end(), tag.begin(), tag.end());
	out.insert(out.end(), enc.begin(), enc.end());

	for (int i : out)
		printf("%02x", i);
	printf("\n");

	in = craftPacket(out, 30000, 30000, 0x0a00003d);
	*/
}